import { fetchAuthor, fetchPost, fetchPosts } from '@/lib/api/posts';
import { getClient } from '@/lib/socket/client';
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
import { validatePost } from './postsValidation';
import type { PostsWithAuthorResponse, PostWithAuthor } from './postTypes';
type GetPostsArgs = Pick<PostsWithAuthorResponse, 'limit' | 'skip'>;

export const postsApiSlice = createApi({
  baseQuery: fetchBaseQuery({ baseUrl: 'https://dummyjson.com' }),
  reducerPath: 'postsApi',
  tagTypes: ['Posts'],
  endpoints: build => ({
    getInfinitePosts: build.infiniteQuery<
      PostsWithAuthorResponse,
      GetPostsArgs,
      number
    >({
      infiniteQueryOptions: {
        initialPageParam: 0,
        getNextPageParam: (lastPage, _pages) => {
          return lastPage.skip + lastPage.limit;
        },
      },
      async onCacheEntryAdded(
        arg,
        { cacheDataLoaded, cacheEntryRemoved, dispatch }
      ) {
        console.log('Attempting to establish WebSocket connection...', { arg });
        const ws = getClient();

        try {
          await cacheDataLoaded;

          const listener = (event: MessageEvent) => {
            const data = JSON.parse(event.data) as PostWithAuthor;
            console.log('Received WebSocket message:', data);

            // Update the cache with the new post and mark it as new manually
            // I tried to follow the instructions at https://redux-toolkit.js.org/rtk-query/usage/streaming-updates
            // but the data was not refreshed in the UI, could be something related to infinite query
            dispatch(
              postsApiSlice.util.updateQueryData(
                'getInfinitePosts',
                arg,
                draft => {
                  // Add the new post to the first page of results
                  if (draft.pages && draft.pages.length > 0 && draft.pages[0]) {
                    // Mark the post as new when adding it
                    draft.pages[0].posts.unshift({ ...data, isNew: true });
                    draft.pages[0].total += 1;
                  }
                }
              )
            );
          };

          ws.addEventListener('message', listener);
        } catch (err) {
          console.error('Error in WebSocket handling:', err);
        }

        await cacheEntryRemoved;
        ws.close();
      },
      queryFn: async ({ queryArg: { limit }, pageParam }) => {
        const response = await fetchPosts(limit, pageParam);
        return { data: response };
      },
      providesTags: (_result, _error, { limit, skip }) => {
        return [{ type: 'Posts', id: `${limit}-${skip}` }];
      },
    }),
    getPost: build.query<PostWithAuthor, { id: number }>({
      queryFn: async ({ id }) => {
        const response = await fetchPost(String(id));
        const post = validatePost(response);
        const author = await fetchAuthor(post.userId);
        return { data: { ...post, author } };
      },
      providesTags: (_result, _error, { id }) => {
        return [{ type: 'Posts', id: `${id}` }];
      },
    }),
  }),
});

// Hooks are auto-generated by RTK-Query
export const { useGetInfinitePostsInfiniteQuery, useGetPostQuery, endpoints } =
  postsApiSlice;
